<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ANIMaker</title>
    <link rel="icon" type="image/svg+xml" href="pngicon.svg" sizes="any">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.11/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.min.js"></script>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --card-bg: #141414;
            --border-color: #2d2d2d;
            --text-main: #e0e0e0;
            --text-dim: #888;
            --accent-white: #ffffff;
            --input-bg: #1f1f1f;
            --hover-bg: #2a2a2a;
        }
        body { 
            font-family: -apple-system, system-ui, sans-serif; 
            background: var(--bg-color); 
            color: var(--text-main);
            padding: 20px; 
            display: flex; 
            justify-content: center; 
            margin: 0;
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
        .card { 
            background: var(--card-bg); 
            padding: 25px; 
            border-radius: 12px; 
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5); 
            width: 100%; 
            max-width: 1100px; 
        }
        .grid { display: grid; grid-template-columns: 360px 1fr; gap: 20px; }
        .section { 
            margin-bottom: 15px; 
            padding: 12px; 
            border: 1px solid var(--border-color); 
            border-radius: 8px; 
            background: #1a1a1a; 
        }
        .drop-row { display: flex; gap: 5px; margin-bottom: 5px; }
        .drop-zone { 
            border: 1px dashed #444; 
            padding: 10px; 
            text-align: center; 
            border-radius: 8px; 
            cursor: pointer; 
            color: var(--text-dim); 
            font-size: 13px; 
            flex-grow: 1; 
            transition: all 0.2s; 
        }
        .drop-zone:hover { border-color: var(--accent-white); color: var(--accent-white); background: var(--hover-bg); }
        .btn-del-small { 
            background: #1a1a1a; 
            border: 1px solid #444; 
            border-radius: 8px; 
            cursor: pointer; 
            padding: 0 12px; 
            color: var(--text-main); 
            transition: 0.2s; 
        }
        .btn-del-small:hover { background: #333; border-color: #888; }
        .layer-btn { 
            background: #1a1a1a; 
            border: 1px solid #444; 
            border-radius: 8px; 
            cursor: pointer; 
            padding: 2px 8px; 
            color: var(--text-dim); 
            font-size: 11px;
            transition: 0.2s; 
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 24px;
        }
        .layer-btn:hover { 
            background: #2a2a2a; 
            border-color: var(--accent-white); 
            color: #fff; 
        }
        .controls-panel { 
            background: #111; 
            color: #fff; 
            padding: 15px; 
            border-radius: 8px; 
            margin-bottom: 10px; 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 12px; 
            border: 1px solid var(--border-color);
        }
        .controls-panel label { font-size: 10px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-dim); display: flex; flex-direction: column; gap: 5px; }
        .controls-panel input { 
            background: var(--input-bg); 
            border: 1px solid #333; 
            color: #fff; 
            padding: 8px; 
            border-radius: 4px; 
            width: 100%; 
            box-sizing: border-box; 
            text-align: center;
        }
        .controls-panel input[type=color] {
            padding: 2px;
            height: 32px;
            cursor: pointer;
        }
        .file-list { 
            max-height: 1000px; 
            overflow-y: auto; 
            border: 1px solid var(--border-color); 
            background: #000; 
            margin-top: 10px; 
            border-radius: 6px; 
        }
        .file-item { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            padding: 8px; 
            border-bottom: 1px solid var(--border-color); 
            font-size: 11px; 
            cursor: grab; 
            background: #111;
            position: relative;
        }
        .file-item.ghost { opacity: 0.3; background: #222; }
        .file-item.drag-over-top { border-top: 2px solid var(--accent-white) !important; }
        .file-item.drag-over-bottom { border-bottom: 2px solid var(--accent-white) !important; }
        .file-item img { width: 35px; height: 35px; object-fit: contain; border: 1px solid #333; background: #fff; border-radius: 4px; }
        .file-item .drag-handle { color: #444; user-select: none; }
        .file-item input { background: #222; border: 1px solid #444; color: #fff; text-align: center; }
        #workArea { 
            position: relative; 
            background: #050505; 
            border-radius: 8px; 
            overflow: hidden; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            min-height: 450px; 
            border: 1px solid var(--border-color);
            padding: 10px;
        }
        #bgCanvasPreview { 
            background-color: #ffffff; 
            box-shadow: 0 0 30px rgba(0,0,0,0.8); 
            cursor: move;
            max-width: 100%;
            max-height: 80vh;
            object-fit: contain;
        }
        .btn { border: 1px solid #444; padding: 12px; border-radius: 6px; cursor: pointer; font-weight: bold; width: 100%; margin-top: 5px; transition: 0.2s; }
        .btn-build { background: var(--accent-white); color: #000; font-size: 14px; margin-top: 15px; border: none; text-transform: uppercase; letter-spacing: 1px; }
        .btn-build:hover { background: #ccc; }
        .btn-build:disabled { background: #333; color: #666; cursor: not-allowed; }
        .btn-opt { 
            background: #1a1a1a; color: #d6d6d6; border: 1px solid #d6d6d6; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin-top: 10px; width: auto; }
        .btn-opt:hover { background: #d6d6d6; color: #000; }
        #status { margin-top: 10px; text-align: center; font-size: 12px; letter-spacing: 1px; min-height: 1.2em; color: var(--text-dim); }
        #loaderStatus { color: var(--text-main); font-size: 11px; text-align: center; margin-top: 5px; display: none; text-transform: uppercase; }
        #resultContainer { 
            margin-top: 25px; 
            padding: 20px; 
            border: 1px solid var(--accent-white); 
            border-radius: 8px; 
            background: #000; 
            display: none; 
            text-align: center;
        }
        #finalPreview { 
            max-width: 100%; 
            max-height: 600px;
            object-fit: contain;
            border: 1px solid #333; 
            background: white; 
            margin-bottom: 15px; 
        }
        .download-btn { 
            display: inline-block; 
            background: var(--accent-white); 
            color: #000; 
            padding: 12px 30px; 
            text-decoration: none; 
            border-radius: 4px; 
            font-weight: bold; 
            text-transform: uppercase; 
            font-size: 12px;
        }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #444; }
    </style>
</head>
<body>
<div class="card">
    <div class="grid">
        <div class="sidebar">
            <h3 style="margin-top:0; letter-spacing: 2px; text-transform: uppercase; font-size: 18px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px;">ANIMaker</h3>
            <div class="section">
                <div class="drop-row">
                    <div id="dzBg" class="drop-zone">ВЫБРАТЬ ФОН (опционально)</div>
                    <button class="btn-del-small" title="Удалить" onclick="removeBg()">X</button>
                </div>
                <div class="drop-row">
                    <div id="dzAnim" class="drop-zone">ВЫБРАТЬ КАДРЫ</div>
                    <button class="btn-del-small" title="Очистить" onclick="clearAllFrames()">X</button>
                </div>
                <input type="file" id="bgIn" style="display:none">
                <input type="file" id="animIn" multiple style="display:none">
            </div>
            <div class="controls-panel">
                <div style="grid-column: 1/3; font-size: 9px; color: #555; text-transform: uppercase; letter-spacing: 2px;">РАЗМЕР ХОЛСТА</div>
                <label>Верх <input type="number" id="padTop" value="0"></label>
                <label>Низ <input type="number" id="padBottom" value="0"></label>
                <label>Лево <input type="number" id="padLeft" value="0"></label>
                <label>Право <input type="number" id="padRight" value="0"></label>
                <div style="grid-column: 1/3; height: 1px; background: #222; margin: 5px 0;"></div>
                <div style="grid-column: 1/3; font-size: 9px; color: #555; text-transform: uppercase; letter-spacing: 2px;">ПОЗИЦИЯ АНИМАЦИИ</div>
                <label>X Pos <input type="number" id="posX" value="0"></label>
                <label>Y Pos <input type="number" id="posY" value="0"></label>
                <div style="grid-column: 1/3; height: 1px; background: #222; margin: 5px 0;"></div>
                <div style="grid-column: 1/3; font-size: 9px; color: #555; text-transform: uppercase; letter-spacing: 2px;">ЦВЕТ ПРЕДПРОСМОТРА</div>
                <label style="grid-column: 1/3;"> <input type="color" id="previewBgColor" value="#ffffff"></label>
<div style="grid-column: 1/3; height: 1px; background: #222; margin: 5px 0;"></div>
<div style="grid-column: 1/3; font-size: 9px; color: #555; text-transform: uppercase; letter-spacing: 2px;">ТАЙМИНГ НА ВСЕ КАДРЫ</div>
<label style="grid-column: 1/3;"> 
    <input type="number" id="globalDelay" value="10" placeholder="введите значение">
</label>            </div>

            <div class="file-list" id="fileList"></div>
            <button class="btn btn-build" id="buildBtn" disabled>СОЗДАТЬ APNG</button>
            <button class="btn btn-build" id="gifBtn" disabled onclick="createGIF()">СОЗДАТЬ GIF</button>
            <button class="btn btn-build" id="spriteBtn" disabled onclick="createSprite()">СОЗДАТЬ СПРАЙТ</button>
            <div id="loaderStatus">LOADING...</div>
            <div id="status"></div>
        </div>
        <div class="main">
            <div id="workArea">
                <canvas id="bgCanvasPreview"></canvas>
            </div>
            <div id="resultContainer">
                <div style="font-size: 10px; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px;">Preview</div>
                <img id="finalPreview">
                <div id="finalSize" style="margin-bottom:15px; font-size: 11px; color: #888;"></div>
                <div>
                    <a id="dlBtn" class="download-btn">СКАЧАТЬ ФАЙЛ</a>
                </div>
                <button class="btn btn-opt" id="optBtn" onclick="optimizeAPNG()">ОПТИМИЗИРОВАТЬ</button>
            </div>
        </div>
    </div>
</div>
<script>
    let bgImg = null;
    let loadedFrames = [];
    let offX = 0, offY = 0, currentFrameIdx = 0;
    let pads = { top: 0, bottom: 0, left: 0, right: 0 };
    let animationTimer = null;
    let dragSrcEl = null;
    const canvas = document.getElementById('bgCanvasPreview');
    const ctx = canvas.getContext('2d');
    const loader = document.getElementById('loaderStatus');
    ['padTop','padBottom','padLeft','padRight'].forEach(id => {
        const el = document.getElementById(id);
        if(el) el.oninput = (e) => {
            pads[id.replace('pad','').toLowerCase()] = parseInt(e.target.value) || 0;
            updateCanvasSize();
        };
    });
    document.getElementById('posX').oninput = e => offX = parseInt(e.target.value)||0;
    document.getElementById('posY').oninput = e => offY = parseInt(e.target.value)||0;
    document.getElementById('previewBgColor').oninput = e => {
        canvas.style.backgroundColor = e.target.value;
    };
    function updateCanvasSize() {
        let w = 100, h = 100;
        if (bgImg) { w = bgImg.width; h = bgImg.height; }
        else if (loadedFrames.length > 0) { w = loadedFrames[0].img.width; h = loadedFrames[0].img.height; }
        canvas.width = w + pads.left + pads.right;
        canvas.height = h + pads.top + pads.bottom;
    }
    function setupZone(id, inId, cb) {
        const z = document.getElementById(id), i = document.getElementById(inId);
        z.onclick = () => i.click();
        z.ondragover = e => { e.preventDefault(); z.style.borderColor = "#fff"; };
        z.ondragleave = () => z.style.borderColor = "#444";
        z.ondrop = e => { e.preventDefault(); z.style.borderColor = "#444"; cb(e.dataTransfer.files); };
        i.onchange = () => cb(i.files);
    }
    setupZone('dzBg', 'bgIn', async f => {
        if(!f.length) return;
        loader.style.display = "block";
        bgImg = await loadImage(f[0]);
        updateCanvasSize();
        loader.style.display = "none";
        if (!animationTimer) startPreviewLoop();
    });
    setupZone('dzAnim', 'animIn', async f => {
        if(!f.length) return;
        loader.style.display = "block";
        const sorted = Array.from(f).sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric:true}));
        for(let file of sorted) {
            const buffer = await file.arrayBuffer();
            const imgData = UPNG.decode(buffer);
            if (imgData.frames && imgData.frames.length > 1) {
                const framesRGBA = UPNG.toRGBA8(imgData);
                for (let i = 0; i < framesRGBA.length; i++) {
                    const rgba = new Uint8ClampedArray(framesRGBA[i]);
                    const fImg = await rgbaToImage(rgba, imgData.width, imgData.height);
                    loadedFrames.push({ 
                        img: fImg, 
                        name: `${file.name}_${i}`, 
                        delay: Math.round(imgData.frames[i].delay / 10) 
                    });
                }
            } else {
                const img = await loadImage(file);
                loadedFrames.push({ img, name: file.name, delay: 10 });
            }
        }
        updateCanvasSize();
        renderList();
        loader.style.display = "none";
        if (!animationTimer) startPreviewLoop();
    });
document.getElementById('globalDelay').oninput = e => {
    const val = parseInt(e.target.value);
    if (isNaN(val)) return;

    loadedFrames.forEach(f => f.delay = val);

    const delayInputs = document.querySelectorAll('.delay-input');
    delayInputs.forEach(input => {
        input.value = val;
    });
};
    function rgbaToImage(rgba, w, h) {
        return new Promise(res => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w; tempCanvas.height = h;
            const tCtx = tempCanvas.getContext('2d');
            const iData = tCtx.createImageData(w, h);
            iData.data.set(rgba);
            tCtx.putImageData(iData, 0, 0);
            const img = new Image();
            img.onload = () => res(img);
            img.src = tempCanvas.toDataURL();
        });
    }
    function removeBg() { bgImg = null; updateCanvasSize(); }
    function clearAllFrames() { loadedFrames = []; renderList(); updateCanvasSize(); }
    function removeFrame(idx) { loadedFrames.splice(idx, 1); renderList(); updateCanvasSize(); }
    function duplicateFrame(idx) {
        const frame = loadedFrames[idx];
        const copy = { ...frame, name: frame.name + "_copy" };
        loadedFrames.splice(idx + 1, 0, copy);
        renderList();
        updateCanvasSize();
    }
    function startPreviewLoop() {
        if(animationTimer) clearTimeout(animationTimer);
        const loop = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (bgImg) ctx.drawImage(bgImg, pads.left, pads.top);
            if (loadedFrames.length > 0) {
                if (currentFrameIdx >= loadedFrames.length) currentFrameIdx = 0;
                const frame = loadedFrames[currentFrameIdx];
                ctx.drawImage(frame.img, offX + pads.left, offY + pads.top);
                const delayInputs = document.querySelectorAll('.delay-input');
                const delayValue = delayInputs[currentFrameIdx] ? (parseInt(delayInputs[currentFrameIdx].value) || 10) : 10;
                currentFrameIdx = (currentFrameIdx + 1) % loadedFrames.length;
                animationTimer = setTimeout(loop, delayValue * 10);
            } else { animationTimer = setTimeout(loop, 100); }
        };
        loop();
    }
    function renderList() {
        const container = document.getElementById('fileList');
        container.innerHTML = loadedFrames.map((f, i) => `
            <div class="file-item" draggable="true" data-index="${i}">
                <span class="drag-handle">::</span>
                <img src="${f.img.src}">
                <input type="number" class="delay-input" value="${f.delay || 10}" style="width:35px; border-radius:2px; padding:2px;">
                <span style="flex-grow:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; opacity:0.7">${f.name}</span>
                <button class="layer-btn" title="Дублировать" onclick="duplicateFrame(${i})">❐</button>
                <button class="layer-btn" title="Удалить" onclick="removeFrame(${i})">X</button>
            </div>
        `).join('');
        container.querySelectorAll('.file-item').forEach(item => {
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragover', handleDragOver);
            item.addEventListener('dragleave', handleDragLeave);
            item.addEventListener('drop', handleDrop);
            item.addEventListener('dragend', handleDragEnd);
        });
        const hasFrames = loadedFrames.length > 0;
        document.getElementById('buildBtn').disabled = !hasFrames;
        document.getElementById('spriteBtn').disabled = !hasFrames;
        document.getElementById('gifBtn').disabled = !hasFrames;
    }
    function handleDragStart(e) { dragSrcEl = this; e.dataTransfer.effectAllowed = 'move'; this.classList.add('ghost'); }
    function handleDragOver(e) {
        if (e.preventDefault) e.preventDefault();
        const rect = this.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        this.classList.remove('drag-over-top', 'drag-over-bottom');
        if (e.clientY < midpoint) { this.classList.add('drag-over-top'); } else { this.classList.add('drag-over-bottom'); }
        return false;
    }
    function handleDragLeave() { this.classList.remove('drag-over-top', 'drag-over-bottom'); }
    function handleDrop(e) {
        if (e.stopPropagation) e.stopPropagation();
        const from = parseInt(dragSrcEl.dataset.index);
        let to = parseInt(this.dataset.index);
        if (this.classList.contains('drag-over-bottom')) { to++; }
        this.classList.remove('drag-over-top', 'drag-over-bottom');
        if (from !== to && from !== to - 1) {
            const movedItem = loadedFrames.splice(from, 1)[0];
            const newTo = from < to ? to - 1 : to;
            loadedFrames.splice(newTo, 0, movedItem);
            renderList();
        }
        return false;
    }
    function handleDragEnd() { 
        this.classList.remove('ghost');
        document.querySelectorAll('.file-item').forEach(el => el.classList.remove('drag-over-top', 'drag-over-bottom'));
    }
    let isDraggingCanvas = false;
    canvas.onmousedown = () => isDraggingCanvas = true;
    window.onmouseup = () => isDraggingCanvas = false;
    canvas.onmousemove = (e) => {
        if (isDraggingCanvas && loadedFrames.length > 0) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            offX = Math.round((e.clientX - rect.left) * scaleX - pads.left - loadedFrames[0].img.width/2);
            offY = Math.round((e.clientY - rect.top) * scaleY - pads.top - loadedFrames[0].img.height/2);
            document.getElementById('posX').value = offX;
            document.getElementById('posY').value = offY;
        }
    };
    async function encodePNG(cColors) {
        const delays = Array.from(document.querySelectorAll('.delay-input')).map(i => (parseInt(i.value)||10)*10);
        const frames = [];
        const W = canvas.width, H = canvas.height;
        for (let f of loadedFrames) {
            const temp = document.createElement('canvas');
            temp.width = W; temp.height = H;
            const tCtx = temp.getContext('2d');
            if (bgImg) tCtx.drawImage(bgImg, pads.left, pads.top);
            tCtx.drawImage(f.img, offX + pads.left, offY + pads.top);
            frames.push(tCtx.getImageData(0,0,W,H).data.buffer);
        }
        return UPNG.encode(frames, W, H, cColors, delays);
    }
    document.getElementById('buildBtn').onclick = async () => {
        const st = document.getElementById('status');
        st.innerText = "PROCESSING...";
        try {
            const resBuf = await encodePNG(0);
            displayResult(resBuf, "output.png");
            st.innerText = " ";
        } catch (e) { console.error(e); st.innerText = "ERROR"; }
    };
    async function createSprite() {
        const st = document.getElementById('status');
        st.innerText = "CREATING SPRITE...";
        try {
            const W = canvas.width, H = canvas.height;
            const spriteCanvas = document.createElement('canvas');
            spriteCanvas.width = W * loadedFrames.length;
            spriteCanvas.height = H;
            const sCtx = spriteCanvas.getContext('2d');
            loadedFrames.forEach((f, i) => {
                const currentX = i * W;
                if (bgImg) sCtx.drawImage(bgImg, currentX + pads.left, pads.top);
                sCtx.drawImage(f.img, currentX + offX + pads.left, offY + pads.top);
            });
            spriteCanvas.toBlob((blob) => { displayResult(blob, "sprite_sheet.png", true); st.innerText = " "; }, 'image/png');
        } catch (e) { console.error(e); st.innerText = "SPRITE ERROR"; }
    }
    async function optimizeAPNG() {
        const st = document.getElementById('status');
        st.innerText = "OPTIMIZING...";
        try {
            const resBuf = await encodePNG(256);
            displayResult(resBuf, "output_optimized.png");
            st.innerText = "OPTIMIZED";
        } catch (e) { st.innerText = "ERROR"; }
    }
    function displayResult(data, filename, isBlob = false) {
        const blob = isBlob ? data : new Blob([data], {type:"image/png"});
        const finalUrl = URL.createObjectURL(blob);
        document.getElementById('finalPreview').src = finalUrl;
        document.getElementById('dlBtn').href = finalUrl;
        document.getElementById('dlBtn').download = filename;
        document.getElementById('finalSize').innerText = "SIZE: " + (blob.size/1024).toFixed(2) + " KB";
        document.getElementById('resultContainer').style.display = "block";
        document.getElementById('resultContainer').scrollIntoView({behavior:'smooth'});
        const isApng = filename.toLowerCase().endsWith('.png') && !filename.includes('sprite_sheet');
        document.getElementById('optBtn').style.display = isApng ? 'inline-block' : 'none';
    }
    async function createGIF() {
        const st = document.getElementById('status');
        st.innerText = "GENERATING GIF...";
        try {
            const workerUrl = 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js';
            const workerResp = await fetch(workerUrl);
            const workerCode = await workerResp.text();
            const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
            const blobWorkerUrl = URL.createObjectURL(workerBlob);
            const W = canvas.width, H = canvas.height;
            const delays = Array.from(document.querySelectorAll('.delay-input')).map(i => (parseInt(i.value) || 10) * 10);
            const gif = new GIF({
                workers: 2, quality: 10, width: W, height: H, workerScript: blobWorkerUrl, transparent: 'rgba(0,0,0,0)'
            });
            for (let i = 0; i < loadedFrames.length; i++) {
                const f = loadedFrames[i];
                const temp = document.createElement('canvas');
                temp.width = W; temp.height = H;
                const tCtx = temp.getContext('2d');
                if (bgImg) { tCtx.drawImage(bgImg, pads.left, pads.top); }
                tCtx.drawImage(f.img, offX + pads.left, offY + pads.top);
                gif.addFrame(temp, {delay: delays[i], copy: true});
            }
            gif.on('finished', function(blob) {
                displayResult(blob, "animation.gif", true);
                st.innerText = " "; URL.revokeObjectURL(blobWorkerUrl);
            });
            gif.render();
        } catch (e) { console.error(e); st.innerText = "GIF ERROR: " + e.message; }
    }
    function loadImage(f) {
        return new Promise(res => {
            const i = new Image();
            i.onload = () => res(i);
            i.src = URL.createObjectURL(f);
        });
    }
</script>
</body>
</html>
